Урок 3. Установка фреймворка
    
    Після установки треба буде налаштувати перенаправлення на папку public

    (httpd)
    
    Варіант 1 (редагування Apache-2.4_vhost.conf):
        <VirtualHost *:80>
            ServerName tlaravel.loc
            DocumentRoot "%sprogdir%/domains/tlaravel.loc/public"
        </VirtualHost>

    Варіант 2 (налаштування OpenServer)
        Домени > Керування доменами > Ручне + Автопошук
        Ім'я домена: tlaravel.loc
        Папка домена: C:\OSPanel\domains\tlaravel.loc\public
        Додати > Зберегти

Урок 4. Структура фреймворка

    app - основна логіка додатку, саме моделі, контролери, посередники і проміжні фільтри, роутери і т.д.
        всі класи описані в просторі імен app
        \<NamespaceName>\<SubNamespaceName>\<ClassName>.php
        User.php - файл моделі по роботі з користувачем
        в корні папки app розташовуються файли моделей
        в інших папках розташовуються контролери

        Console - надає доступ до АРІ фреймворку по протоколу CLI
            можна отримувати доступ до фреймворка, використвуючи командний рядок

        Http - містяться контролери, посередники, класи запитів (класи валідації користувацького введення)
            Kernel.php - це http-ядро, ядро обробки запитів, які передаються по протоколу http до фреймворку
            Routes.php - в цьому файлі будуть описані маршрути, які будуть формувати функціонал програми

        Events - зберігаються класи подій

        Exceptions - містить обробники виключень, можна розміщувати класи виключень

        Jobs - містяться класи черг, тобто можна визначити задачі, які будуть поставлені в чергу, або ж працювати синхронно в межах одного запиту

        Listeners - містить обробники подій, які відбуваються при спрацьовуванні тієї чи іншої події

        Policies - містить класи політики безпеки додатку. Політика безпеки застосовуються для визначення прав користувача для виконання певної дії

        Providers - містить сервіс-провайдери додатку

    bootstrap - файли, які виконують першочергове завантаження фреймворку і налаштовують автозавантаження класів
        містить ті файли, які повинні відпрацювати в першочерговий момент роботи додатку в цілому

    config - конфігураційні файли додатку

    database - містить файли міграції баз даних і посіву даних (це додавання даних в певні таблиці)

    public - збергіається глобальна точка входу у Laravel. Треба зберігати всі ті дані, до яких можна надати публічний доступ
        треба зберігати сюди зображення, стилі, скрипти і т.д.

    resources - містить шаблони, вигляди, файли локалізації і робочі файли LESS, SASS і JS додатку

    storage - містить скомпільовані blade-шаблони, файли сесій, файли кешу і інші системні тимчасові файли

    tests - зберігаються unit-тести

    vendor - зберігаються всі скачані бібліотеки і класи
        сирцевий код фреймворка, всі сторонні бібліотеки, від яких залежить його робота

    .env - файл, в якому описані змінні оточення, налаштування

    .env.example - приклад оформлення файлу, в якому містяться змінні оточення

    .gitattributes - необхідний для роботи системи контроля версій Git

    .gitignore - необхідний для роботи системи контроля версій Git

    artisan - надає доступ до консолі фреймворка

    composer.json - файл, який згенерований Composer і містить всі залежності, від яких залежить функціонал фреймворку

    composer.lock - містить статус установки бібліотек, від яких залежить функціонал фреймворку

    gulpfile.js - файл, які потрібні для роботи спеціального інструменту Laravel Elixir

    package.json - файл, які потрібні для роботи спеціального інструменту Laravel Elixir

    phpunit.xml - містить налаштування системи тестування php unit

    server.php - файл, який емулює роботу модуля перенаправлень сервера Apache

Урок 5. Налаштування конфігурації фреймворка

    Змінні оточення - це ті налаштування, які змінюються під час розробки додатку

    Вміст файлу .env:

        APP_ENV - назва середовища розробки, тобто всі наступні параметри відносяться до певного середовища розробки

        APP_DEBUG - увімкнення режиму відлагодження. Якщо true, то фреймворк буде відображати детальні дані про помилки

        APP_KEY - 32-символьний рядок, який використовується для шифрування даних у фреймворку

        DB_HOST - путь до сервера, його ір

        DB_DATABASE - назва бази даних

        DB_USERNAME - ім'я користувача

        DB_PASSWORD - пароль користувача

        CACHE_DRIVER - налаштування системи кешування

        SESSION_DRIVER - налаштування по роботі з сесіями

        QUEUE_DRIVER - налаштування по роботі

        REDIS_... - налаштування підключення до Redis

        MAIL_... - налаштування відправлення електронних листів

    Папка config

        app.php - глобальні налаштування роботи всього фреймворка в цілому

        database.php - налаштування бази даних

        mail.php - налаштування пошти

        view.php - налаштування видів

    Консоль

        artisan - доступо до консолі

        php artisan - доступ до команд консолі

        php artisan app:name Test - змінити назву кореневого простору імен

    APP_KEY - ключ, який використовується для шифрування даних
        можна згенерувати, використовуючи консоль

        php artisan key:generate - згенерувати новий ключ додатку

Урок 6. Принцип роботи по MVC шаблону

    Принцип роботи:
        Запит сторінки > точка входу > маршрутизатор > контролер > модель > БД > контролер > вид > відображення даних

    routes.php - маршрутизатор фреймворка
        Знаходиться в папці routes/web.php (з версії 5.3)

    Щоб створити новий маршрут, треба в роутері прописати шлях до маршрута і у виді додати сторінку виду name.blade.php

Урок 7. Типи запитів для передачі даних в маршрутизації (GET | POST)

    Маршрутизація - процес отримання частини запиту користувача, тобто тієї частини запиту, яка знаходиться після базового URL і її розкладення на параметри для визначення того, який контролер і яка дія даного контролера повинні виконати поставлений запит
        Також це передача керування певному контролеру.
        Це процес розбору частини URI і пошук співпадання з описаним раніше маршрутом або роутером і наступним викликом обробника маршрута

    Маршрут - це метод, в якому визначений шаблон частини URI і функція обробник, яка буде виконана при співпаданні поточного запиту

    Uniform Resource Identifier (єдинообразний ідентифікатор ресурса)
        URI = http://domen.ua/articles/internet/article.html

    Uniform Resource Locator (єдинообразний вказівник ресурса)
        URL = http://domen.ua

    Uniform Resource Name (єдинообразний вказівник імені)
        URN = /articles/internet/article.html

    Протокол HTTP описує взаємодію між 2 комп'ютерами: сервером і клієнтом
        Дана взаємодія будується на базі запитів і повідомлень  
        Кожне повідомлення (запит) скаладється із 3 частин:
            Стартовий рядок (обов'язково)
            Заголовок (набір пар ім'я - значення)
            Тіло повідомлення (дані)

    Для розмежування дій з ресурсами на рівні HTTP були придумані наступні варіанти:
        GET - отримання ресурса (обов'язковий)
        POST - створення ресурса
        PUT - оновлення ресурса
        DELETE - видалення ресурса


    При отриманні запиту DELETE сервер не повинен обов'язково видалити ресурс. Це вирішує уже розробник

    REST

    Фасад - спеціальний клас, який надає доступ до деякого елементу фреймворка Laravel
        Клас, який надає спрощений доступ до іншого класу

    match() для вибору декількох видів типів запитів

Урок 8. Параметри маршрутів

    При формуванні запитів для того, щоб вказати параметри, їх треба вказувати в {id} і вказати ім'я параметра
        // Route::get('/page/{id}', function () {

    Параметри у функцію-обробник потрапляють по порядку, а не по іменам

    Якщо параметр не обов'язковий, то після нього потрібно поставити ?
        Наприклад {id?}

    Глобальні параметри умови для роутерів можна визначити у RouteServiceProvider.php, метод boot (app/Providers)

    Групування маршрутів (наприклад всі маршрути в папці admin матимуть це слово на початку)
        // Route::group(['prefix' => 'admin'], function (){

Урок 9. Контролери

    app > Http > Controllers
    
    Контролери дозволяють винести код обробника роутера в окремий файл

    Route::get('/about', 'FirstController@show');
        метод show() контролера FirstController обробить даний запит користувача

    php artisan make:controller Core - команда для artisan щоб створити контролер

    Створюючи маршрути в якості обробника можна використовувати як різні контролери, так і один єдиний контролер, але з різними методами

    Маршрути потрібно іменувати

    Контролери типу ресурс створюються для створення RESTful систем

    Управління інформацією створюваного сервіса повністю залежить від протоколу передачі даних

    Ресурс https://laravel.com/docs/5.2/controllers#restful-resource-controllers

Урок 10. Middleware. Класи-посередники

    Класи посередники - це фільтри обробки HTTP-запитів
        app > Http > Middleware

    Наприклад, є посередники, які потрібні для перевірки авторизації користувача, перевірка на права користувача для перегляду тієї чи іншої сторінки

    Дозволяють виконати певну дію, до обробки запиту і формуванняя відповіді.

    За допомогою ::class можна отримати повну назву класа

    Якщо визначити посередник глобально, то доступ до поточного маршрута отримати не можна

    php artisan make:middleware Mymiddleware

Урок 11. Шаблони представлення. Види.

    Вид - це шаблон, який повинен відобразити дані проекта на екран користувача

    В шаблонх не потрібно зберігати ніяку логіку, яка стосується обробки чи зміни даних

    view() - це функція хелпер

Урок 12. Шаблонізатор Blade

    Шаблони: resources > views
    Скомпільовані шаблони: storage > framework > views

    Шаблонізатор - це спеціальний механізм, який використовується для підстановки даних в визначені місця шаблона і формування вигляду проекту

    Шаблон - це документ в форматі .php, який містить в собі HTML-теги а також спеціальні мітки, замість яких потім вставляютсья дані з логічної частини

    Якщо використовується шаблонізатор, то не повинно бути жодного рядка коду на мові PHP

    Робота шаблонізатора зводиться до компіляції шаблонів
        Послідовно зчитує розмітку і створює РНР сценарій

    @section('navbar') - оголошення початку секції

    @endsection - оголошення кінця секції

    @yield('navbar') - відображення секції

    @show - закрити тег section і відразу ж відобразити вміст секції

    @extends('default.layouts.layout') - даний шаблон наслідує функціонал батьківського макету

    В дочірніх макетх можна перевизначати секції

    @parent - повертає вміст батьківської секції

    @include - підключення коду з іншої секції

    Макети виступають в ролі батьківських шаблонів, які наслідуються дочірніми шаблонами

Урок 13. Умовні і циклічні директиви шаблонізатора Blade

    Виведення даних можна здійснювати за допомогою {{ }}

    {!! !!} - виведення тексту з відключенням функції htmlentities (для виведення скриптів наприклад)

    @{{ var }} - не буде враховуватися шаблонізатором

    {{ isset($bvar) ? $bvar : $title}} - простий тернарний оператор

    {{ $bvar or $title}} - тернарний оператор шаблонізатора

    Умовний оператор if
        @if(count($data) < 3)
            В масиві менше 3 елементів
        @elseif (count($data) > 10)
            В масиві більше 10 елементів
        @else
            В масиві багато елементів
        @endif

    Цикл for
        @for($i = 0; $i < count($dataI); $i++)
            <li>{{ $dataI[$i]}}</li>
        @endfor

    Цикл foreach
        @foreach($data as $k => $value)
            <li>{{ $k.' => '.$value }}</li>
        @endforeach

    Цикл forelse (вбудована перевірка на пустоту)
        @forelse($data as $k => $value)
            <li>{{ $k.' => '.$value }}</li>
            @empty
                <p>No items</p>
        @endforelse

    Цикл while
        @while (FALSE)
            <p>I'm looping forever</p>
        @endwhile

    each - обходить за допомогою масива вміст масива і на кожній ітерації циклу вміст комірок масиву потрапляє в змінну value
        вміст змінної на кожній ітерації циклу передається у певний вид, який вказаний в параметрах
        @each('default.list', $dataI, 'value')

Урок 14. Клас Request

    Клас Request - абстракція відправлюваного запиту користувача

    Отримуємо метод ядра обробника запитів
        $kernel = $app->make(Illuminate\Contracts\Http\Kernel::class);

    Обробник запиту користувача handle()
        $response = $kernel->handle(
            $request = Illuminate\Http\Request::capture()
        );

    Request - абстракція запиту

    За допомогою метода input можна отримати доступ до однієї змінної в запиті

    Метод has() - повертає true, якщо комірка, ім'я якої передають присутня у масиві даних запиту і не пусте

    Метод all() - передає всі параметри, які передаються у вигляді масиву
        all() - для всіх
        only() - для деяких
        except() - виключаючи; ті комірки, які нас не цікавлять

    Методи для роботи з адресним рядком
        path() - повертає частину URI, сам запит, все, крім домену сайта
        is() - перевіряє, чи path співпадає з деяким шаблоном
        url() - повертає шлях із адресного рядка, але без GET-параметрів, які передаються
        fullUrl() - повертає повний шлях із адресного рядка
        method() - повертає тип запиту користувача (GET, POST, PUT, DELETE)
        isMethod() - перевірка на те, який метод використовує користувач
        flash() - зберігає всі дані в сесії, які були передані в тілі запиту
        flashOnly() - визначає лише ті комірки, які потрібно зберегти в сесії
        flashExcept() - визначає лише ті комірки, які не потрібно зберігати
        withInput() - зберігаємо весь вміст об'єкта Request в сесію
        flush() - очистити дані, записані в сесію

Урок 15. Формування відповіді. Клас Response

    Об'єкт класу Response - це абстракція відповіді

    Відповідь складається з заголовків і з контенту

    Метод send() відправляє відповідь користувачу

    Метод view() повертає об'єкт класу Response для конкретного виду

    Метод back() виконує перенаправлення на попередню сторінку

    Повертаємо об'єкт класа Response: return (new Response('hello'));

    Завантаження файлу: return response()->download('robots.txt', 'mytext.txt');

Урок 16. Міграції. Контроль версій БД. Побудова таблиць в БД.

    database > migrations

    Міграції - спрощена система контроля версій для БД.

    PDO - PHP Data Object використовується в Laravel.

    Консольна команда для створення міграції php artisan make:migration create_articles_table

    Метод down() у міграції відмінить дію, яка була у методі up()

    Клас Schema:: спеціальний конструктор таблиць

    Консольна команда для застосування всіх міграцій php artisan migrate

    php atrisan migrate - створює міграції
    php artisan migrate:rollback - відміняє міграції на попередньому кроці

Урок 17. Заповнення таблиць інформацією

    database > seeds - класи, які реалізують механізм посіву даних

    php artisan make:seeder ArticlesSeeder - створити сідер

    DatabaseSeeder.php - стандартний сідер, в якому можна вказати користувацькі сідери

    Сідери використовуються для того, щоб заповнювати таблиці даними

    Є три способи заповнення даних в таблиці

Урок 18. Робота з БД, SQL-запити, фасад DB

    Фасад DB надає доступ для використання
        select - вибірка інформації
        insert - вставка
        update - оновлення
        delete - видалення
        statement - інші запити, не пов'язані з вищеперечисленими
        listen - дозволяє прослуховувати всі SQL-запити у сервіс-провайдері

    dump() - для дампового виведення змінної

Урок 19. Конструктор запитів

    Конструктор - спеціальний клас з набором визначених методів, кожен з яких формує частину майбутнього SQL-запиту

    Викликаючи почергово методи конструктора ми формуємо запит, який буде виконаний

    Фасад DB::table('tableName')-> + метод

Урок 20. Модель даних Eloquent

    Модель - абстракція окремого запису, який розташовується в конкретній таблиці БД, об'єктне представлення елемента таблиці
        Об'єкт певного класу, у властивостях якого розташовуються дані полів таблиці

    Моделі знаходяться в app

    php artisan make:model Page - створити модель
    php artisan make:model Page -m - створити модель і міграцю

Урок 21. Модель даних Eloquent (softDelete, create, delete, update)

    Робота з методом create()

    По замовчуванню фреймворк забороняє вставляти дані в таблиці методом create() для досягнення найбільшої безпеки

    У моделі можна визначати, які поля можна заповняти, а які — не можна (fillable, guarded)

    softDelete реалізує щось схоже на корзину, робить помітку в полі deleted_at

Урок 22. Модель даних Eloquent. Зв'язки між таблицями

    Створюючи таблиці, ми їх можемо зв'язати, використовуючи зовнішній ключ

    Один до одного (користувач - місто, тобто один користувач може проживати лише в одному місті)

    Зовнішній ключ: $table->foreign('user_id')->references('id')->on('users');

    Зв'язок моделі користувача: return $this->hasOne('App\Country');

    Один до багатьох. (користувач - записи, один користувач і багато записів)

    Багато до багатьох. Користувачі і ролі. Користувач може мати багато ролей. А ролі можуть мати багато користувачів

Урок 23. Використання зв'язків між моделями Eloquent. Вставка і редагування

    Жадне завантаження дозволяє значно зменшити кількість запитів, виконуваних на сервері БД

    Ліниве завантаження - завантажити всі записи і потім звертатися до моделі користувача, щоб завантажувати записи по одному

    Жадне завантаження - дані з таблиць підвантажуються одночасно з колекцією моделей
    $articles = Article::with('user')->get();
    або
    $articles->load('user');

    Метод has() дозволяє вибрати інформацію для конкретної моделі якщо у неї є визначений зв'язок з моделлю

    Якщо працюємо з масивом даних, то для додавання більш коректно використовувати метод create()

    Якщо працюємо з моделями, то більш коректно використовувати метод save()

    Для редагування використовуємо метод update()

Урок 24. Мутатори

    Метод associate() використовується для змінення зв'язків між моделями

    associate() змінює значення визначеної властивості моделі

    attach() створює новий запис в таблиці для зв'язку багато до багатьох
    detach() видаляє створений запис в таблиці для зв'язку багато до багатьох

    Методи читачі - accessors
       Виконують певний код, коли відбувається звернення до властивості моделі

    Методи перетворювачі - мутатори
        Виконують певний код, коли відбувається змінення властивостей моделі

Урок 25. Валідація даних

    Валідація - перевірка вхідних даних на відповідність певним правилам

    ValidatesRequests - трейт, який потрібний для валідації данних

    validate() - метод, який реалізує процес валідації даних

    Правила:
        required - обов'язкове для заповнення
        max:10 - максимум 10 символів
        email - перевірка на правильність заповнення email

    Усі правила валідації: https://laravel.com/docs/5.2/validation#available-validation-rules

Урок 26. Валідація масивів

    Ручна побудова валідатора здійснюється за допомогою фасада Validator::

    Фасад надає доступ до чого-небудь

Урок 27. Повідомлення помилок валідації

    Всі правила валідації знаходяться в resources > lang > en > validation.php

    В масиві custom можна описати свої помилки валідації

    Параметри, які задаються в правилах і виводяться в помилках вказуються так - :max, :name

    Метод messages() буде також використовуватися для формування власних повідомлень в класі для валідації даних

    Масив messages[] - це масив користувацьких повідомлень про помилки валідації

    $this->validate($request, $rules, $messages);

    fails() повертає істину, якщо валідація була завершена з помилками

Урок 28. Автентифікація користувачів

    Автентифікація - це процес перевірки користувача з даними зареєстрованих користувачів сайту

    Авторизація - процес перевірки прав користувача на виконання дії

    config > auth.php

    defaults - стандартні налаштування
        guard - група налаштувань
        passwords - параметр, який визначає логіку скидання пароля (група налаштувань)

    guards - доступні охоронці нашого додатку
        web - група налаштувань
            driver - як буде передаватися інформація про те, що користувач автентифікований (session чи token)
            provider - вказує як будуть витягуватися дані про користувача

    providers - механізм, який дозволяє витягнути з деякого сховища інформацію про користувача

    users - група налаштувань
        driver - використання драйвера (реляційна модель eloquent)
        model - модель, яка буде використовуватися для роботи з користувачем

    passwords - налаштовує механізм скидання паролю
        users - група налаштувань
            provider - провайдер, який використовується для доступу до інформації користувача
            email - інформація про шаблон сторінки скидання пароля користувача
            table - назва таблиці, яка буде використовуватися для скидання пароля
            expire -

    Механізм аутентифікації користувачів складається з 2 частин:
        guards - охоронець
        providers - провайдер

    guards - визначає як користувачі проходять перевірку достовірності для кожного запиту

    providers - визначає, як можна отримати дані користувача з БД чи іншого місця зберігання інформації

    Можно створювати свої guard i provider

    php artisan make:auth

    resources > views > login.blade.php - вид для здійснення аутентифікації
    resources > views > register.blade.php - ви для реєстрації

    resources > views > emails > password.blade.php - шаблон листа, який буде надісланий на пошту для скидання пароля

    Шаблони, які необхідні для системи скидання паролю користувачів:
        resources > views > passwords > email.blade.php
        resources > views > passwords > reset.blade.php

    php artisan route:list - переглянути зареєстровані роути