Урок 3. Установка фреймворка
    
    Після установки треба буде налаштувати перенаправлення на папку public

    (httpd)
    
    Варіант 1 (редагування Apache-2.4_vhost.conf):
        <VirtualHost *:80>
            ServerName tlaravel.loc
            DocumentRoot "%sprogdir%/domains/tlaravel.loc/public"
        </VirtualHost>

    Варіант 2 (налаштування OpenServer)
        Домени > Керування доменами > Ручне + Автопошук
        Ім'я домена: tlaravel.loc
        Папка домена: C:\OSPanel\domains\tlaravel.loc\public
        Додати > Зберегти

Урок 4. Структура фреймворка

    app - основна логіка додатку, саме моделі, контролери, посередники і проміжні фільтри, роутери і т.д.
        всі класи описані в просторі імен app
        \<NamespaceName>\<SubNamespaceName>\<ClassName>.php
        User.php - файл моделі по роботі з користувачем
        в корні папки app розташовуються файли моделей
        в інших папках розташовуються контролери

        Console - надає доступ до АРІ фреймворку по протоколу CLI
            можна отримувати доступ до фреймворка, використвуючи командний рядок

        Http - містяться контролери, посередники, класи запитів (класи валідації користувацького введення)
            Kernel.php - це http-ядро, ядро обробки запитів, які передаються по протоколу http до фреймворку
            Routes.php - в цьому файлі будуть описані маршрути, які будуть формувати функціонал програми

        Events - зберігаються класи подій

        Exceptions - містить обробники виключень, можна розміщувати класи виключень

        Jobs - містяться класи черг, тобто можна визначити задачі, які будуть поставлені в чергу, або ж працювати синхронно в межах одного запиту

        Listeners - містить обробники подій, які відбуваються при спрацьовуванні тієї чи іншої події

        Policies - містить класи політики безпеки додатку. Політика безпеки застосовуються для визначення прав користувача для виконання певної дії

        Providers - містить сервіс-провайдери додатку

    bootstrap - файли, які виконують першочергове завантаження фреймворку і налаштовують автозавантаження класів
        містить ті файли, які повинні відпрацювати в першочерговий момент роботи додатку в цілому

    config - конфігураційні файли додатку

    database - містить файли міграції баз даних і посіву даних (це додавання даних в певні таблиці)

    public - збергіається глобальна точка входу у Laravel. Треба зберігати всі ті дані, до яких можна надати публічний доступ
        треба зберігати сюди зображення, стилі, скрипти і т.д.

    resources - містить шаблони, вигляди, файли локалізації і робочі файли LESS, SASS і JS додатку

    storage - містить скомпільовані blade-шаблони, файли сесій, файли кешу і інші системні тимчасові файли

    tests - зберігаються unit-тести

    vendor - зберігаються всі скачані бібліотеки і класи
        сирцевий код фреймворка, всі сторонні бібліотеки, від яких залежить його робота

    .env - файл, в якому описані змінні оточення, налаштування

    .env.example - приклад оформлення файлу, в якому містяться змінні оточення

    .gitattributes - необхідний для роботи системи контроля версій Git

    .gitignore - необхідний для роботи системи контроля версій Git

    artisan - надає доступ до консолі фреймворка

    composer.json - файл, який згенерований Composer і містить всі залежності, від яких залежить функціонал фреймворку

    composer.lock - містить статус установки бібліотек, від яких залежить функціонал фреймворку

    gulpfile.js - файл, які потрібні для роботи спеціального інструменту Laravel Elixir

    package.json - файл, які потрібні для роботи спеціального інструменту Laravel Elixir

    phpunit.xml - містить налаштування системи тестування php unit

    server.php - файл, який емулює роботу модуля перенаправлень сервера Apache

Урок 5. Налаштування конфігурації фреймворка

    Змінні оточення - це ті налаштування, які змінюються під час розробки додатку

    Вміст файлу .env:

        APP_ENV - назва середовища розробки, тобто всі наступні параметри відносяться до певного середовища розробки

        APP_DEBUG - увімкнення режиму відлагодження. Якщо true, то фреймворк буде відображати детальні дані про помилки

        APP_KEY - 32-символьний рядок, який використовується для шифрування даних у фреймворку

        DB_HOST - путь до сервера, його ір

        DB_DATABASE - назва бази даних

        DB_USERNAME - ім'я користувача

        DB_PASSWORD - пароль користувача

        CACHE_DRIVER - налаштування системи кешування

        SESSION_DRIVER - налаштування по роботі з сесіями

        QUEUE_DRIVER - налаштування по роботі

        REDIS_... - налаштування підключення до Redis

        MAIL_... - налаштування відправлення електронних листів

    Папка config

        app.php - глобальні налаштування роботи всього фреймворка в цілому

        database.php - налаштування бази даних

        mail.php - налаштування пошти

        view.php - налаштування видів

    Консоль

        artisan - доступо до консолі

        php artisan - доступ до команд консолі

        php artisan app:name Test - змінити назву кореневого простору імен

    APP_KEY - ключ, який використовується для шифрування даних
        можна згенерувати, використовуючи консоль

        php artisan key:generate - згенерувати новий ключ додатку

Урок 6. Принцип роботи по MVC шаблону

    Принцип роботи:
        Запит сторінки > точка входу > маршрутизатор > контролер > модель > БД > контролер > вид > відображення даних

    routes.php - маршрутизатор фреймворка
        Знаходиться в папці routes/web.php (з версії 5.3)

    Щоб створити новий маршрут, треба в роутері прописати шлях до маршрута і у виді додати сторінку виду name.blade.php

Урок 7. Типи запитів для передачі даних в маршрутизації (GET | POST)

    Маршрутизація - процес отримання частини запиту користувача, тобто тієї частини запиту, яка знаходиться після базового URL і її розкладення на параметри для визначення того, який контролер і яка дія даного контролера повинні виконати поставлений запит
        Також це передача керування певному контролеру.
        Це процес розбору частини URI і пошук співпадання з описаним раніше маршрутом або роутером і наступним викликом обробника маршрута

    Маршрут - це метод, в якому визначений шаблон частини URI і функція обробник, яка буде виконана при співпаданні поточного запиту

    Uniform Resource Identifier (єдинообразний ідентифікатор ресурса)
        URI = http://domen.ua/articles/internet/article.html

    Uniform Resource Locator (єдинообразний вказівник ресурса)
        URL = http://domen.ua

    Uniform Resource Name (єдинообразний вказівник імені)
        URN = /articles/internet/article.html

    Протокол HTTP описує взаємодію між 2 комп'ютерами: сервером і клієнтом
        Дана взаємодія будується на базі запитів і повідомлень  
        Кожне повідомлення (запит) скаладється із 3 частин:
            Стартовий рядок (обов'язково)
            Заголовок (набір пар ім'я - значення)
            Тіло повідомлення (дані)

    Для розмежування дій з ресурсами на рівні HTTP були придумані наступні варіанти:
        GET - отримання ресурса (обов'язковий)
        POST - створення ресурса
        PUT - оновлення ресурса
        DELETE - видалення ресурса


    При отриманні запиту DELETE сервер не повинен обов'язково видалити ресурс. Це вирішує уже розробник

    REST

    Фасад - спеціальний клас, який надає доступ до деякого елементу фреймворка Laravel
        Клас, який надає спрощений доступ до іншого класу

    match() для вибору декількох видів типів запитів

Урок 8. Параметри маршрутів

    При формуванні запитів для того, щоб вказати параметри, їх треба вказувати в {id} і вказати ім'я параметра
        // Route::get('/page/{id}', function () {

    Параметри у функцію-обробник потрапляють по порядку, а не по іменам

    Якщо параметр не обов'язковий, то після нього потрібно поставити ?
        Наприклад {id?}

    Глобальні параметри умови для роутерів можна визначити у RouteServiceProvider.php, метод boot (app/Providers)

    Групування маршрутів (наприклад всі маршрути в папці admin матимуть це слово на початку)
        // Route::group(['prefix' => 'admin'], function (){

Урок 9. Контролери

    app > Http > Controllers
    
    Контролери дозволяють винести код обробника роутера в окремий файл

    Route::get('/about', 'FirstController@show');
        метод show() контролера FirstController обробить даний запит користувача

    php artisan make:controller Core - команда для artisan щоб створити контролер

    Створюючи маршрути в якості обробника можна використовувати як різні контролери, так і один єдиний контролер, але з різними методами

    Маршрути потрібно іменувати

    Контролери типу ресурс створюються для створення RESTful систем

    Управління інформацією створюваного сервіса повністю залежить від протоколу передачі даних

    Ресурс https://laravel.com/docs/5.2/controllers#restful-resource-controllers

Урок 10. Middleware. Класи-посередники

    Класи посередники - це фільтри обробки HTTP-запитів
        app > Http > Middleware

    Наприклад, є посередники, які потрібні для перевірки авторизації користувача, перевірка на права користувача для перегляду тієї чи іншої сторінки

    Дозволяють виконати певну дію, до обробки запиту і формуванняя відповіді.

    За допомогою ::class можна отримати повну назву класа

    Якщо визначити посередник глобально, то доступ до поточного маршрута отримати не можна

    php artisan make:middleware Mymiddleware

Урок 11. Шаблони представлення. Види.

    Вид - це шаблон, який повинен відобразити дані проекта на екран користувача

    В шаблонх не потрібно зберігати ніяку логіку, яка стосується обробки чи зміни даних

    view() - це функція хелпер

Урок 12. Шаблонізатор Blade

    Шаблони: resources > views
    Скомпільовані шаблони: storage > framework > views

    Шаблонізатор - це спеціальний механізм, який використовується для підстановки даних в визначені місця шаблона і формування вигляду проекту

    Шаблон - це документ в форматі .php, який містить в собі HTML-теги а також спеціальні мітки, замість яких потім вставляютсья дані з логічної частини

    Якщо використовується шаблонізатор, то не повинно бути жодного рядка коду на мові PHP

    Робота шаблонізатора зводиться до компіляції шаблонів
        Послідовно зчитує розмітку і створює РНР сценарій

    @section('navbar') - оголошення початку секції

    @endsection - оголошення кінця секції

    @yield('navbar') - відображення секції

    @show - закрити тег section і відразу ж відобразити вміст секції

    @extends('default.layouts.layout') - даний шаблон наслідує функціонал батьківського макету

    В дочірніх макетх можна перевизначати секції

    @parent - повертає вміст батьківської секції

    @include - підключення коду з іншої секції

    Макети виступають в ролі батьківських шаблонів, які наслідуються дочірніми шаблонами

Урок 13. Умовні і циклічні директиви шаблонізатора Blade

    Виведення даних можна здійснювати за допомогою {{ }}

    {!! !!} - виведення тексту з відключенням функції htmlentities (для виведення скриптів наприклад)

    @{{ var }} - не буде враховуватися шаблонізатором

    {{ isset($bvar) ? $bvar : $title}} - простий тернарний оператор

    {{ $bvar or $title}} - тернарний оператор шаблонізатора

    Умовний оператор if
        @if(count($data) < 3)
            В масиві менше 3 елементів
        @elseif (count($data) > 10)
            В масиві більше 10 елементів
        @else
            В масиві багато елементів
        @endif

    Цикл for
        @for($i = 0; $i < count($dataI); $i++)
            <li>{{ $dataI[$i]}}</li>
        @endfor

    Цикл foreach
        @foreach($data as $k => $value)
            <li>{{ $k.' => '.$value }}</li>
        @endforeach

    Цикл forelse (вбудована перевірка на пустоту)
        @forelse($data as $k => $value)
            <li>{{ $k.' => '.$value }}</li>
            @empty
                <p>No items</p>
        @endforelse

    Цикл while
        @while (FALSE)
            <p>I'm looping forever</p>
        @endwhile

    each - обходить за допомогою масива вміст масива і на кожній ітерації циклу вміст комірок масиву потрапляє в змінну value
        вміст змінної на кожній ітерації циклу передається у певний вид, який вказаний в параметрах
        @each('default.list', $dataI, 'value')

Урок 14. Клас Request

    Клас Request - абстракція відправлюваного запиту користувача

    Отримуємо метод ядра обробника запитів
        $kernel = $app->make(Illuminate\Contracts\Http\Kernel::class);

    Обробник запиту користувача handle()
        $response = $kernel->handle(
            $request = Illuminate\Http\Request::capture()
        );

    Request - абстракція запиту

    За допомогою метода input можна отримати доступ до однієї змінної в запиті

    Метод has() - повертає true, якщо комірка, ім'я якої передають присутня у масиві даних запиту і не пусте

    Метод all() - передає всі параметри, які передаються у вигляді масиву
        all() - для всіх
        only() - для деяких
        except() - виключаючи; ті комірки, які нас не цікавлять

    Методи для роботи з адресним рядком
        path() - повертає частину URI, сам запит, все, крім домену сайта
        is() - перевіряє, чи path співпадає з деяким шаблоном
        url() - повертає шлях із адресного рядка, але без GET-параметрів, які передаються
        fullUrl() - повертає повний шлях із адресного рядка
        method() - повертає тип запиту користувача (GET, POST, PUT, DELETE)
        isMethod() - перевірка на те, який метод використовує користувач
        flash() - зберігає всі дані в сесії, які були передані в тілі запиту
        flashOnly() - визначає лише ті комірки, які потрібно зберегти в сесії
        flashExcept() - визначає лише ті комірки, які не потрібно зберігати
        withInput() - зберігаємо весь вміст об'єкта Request в сесію
        flush() - очистити дані, записані в сесію

Урок 15. Формування відповіді. Клас Response

    Об'єкт класу Response - це абстракція відповіді

    Відповідь складається з заголовків і з контенту

    Метод send() відправляє відповідь користувачу

    Метод view() повертає об'єкт класу Response для конкретного виду

    Метод back() виконує перенаправлення на попередню сторінку

    Повертаємо об'єкт класа Response: return (new Response('hello'));

    Завантаження файлу: return response()->download('robots.txt', 'mytext.txt');

Урок 16. Міграції. Контроль версій БД. Побудова таблиць в БД.

    database > migrations

    Міграції - спрощена система контроля версій для БД.

    PDO - PHP Data Object використовується в Laravel.

    Консольна команда для створення міграції php artisan make:migration create_articles_table

    Метод down() у міграції відмінить дію, яка була у методі up()

    Клас Schema:: спеціальний конструктор таблиць

    Консольна команда для застосування всіх міграцій php artisan migrate

    php atrisan migrate - створює міграції
    php artisan migrate:rollback - відміняє міграції на попередньому кроці

Урок 17. Заповнення таблиць інформацією

    database > seeds - класи, які реалізують механізм посіву даних

    php artisan make:seeder ArticlesSeeder - створити сідер

    DatabaseSeeder.php - стандартний сідер, в якому можна вказати користувацькі сідери

    Сідери використовуються для того, щоб заповнювати таблиці даними

    Є три способи заповнення даних в таблиці

Урок 18. Робота з БД, SQL-запити, фасад DB

    Фасад DB надає доступ для використання
        select - вибірка інформації
        insert - вставка
        update - оновлення
        delete - видалення
        statement - інші запити, не пов'язані з вищеперечисленими
        listen - дозволяє прослуховувати всі SQL-запити у сервіс-провайдері

    dump() - для дампового виведення змінної

Урок 19. Конструктор запитів

    Конструктор - спеціальний клас з набором визначених методів, кожен з яких формує частину майбутнього SQL-запиту

    Викликаючи почергово методи конструктора ми формуємо запит, який буде виконаний

    Фасад DB::table('tableName')-> + метод

Урок 20. Модель даних Eloquent

    Модель - абстракція окремого запису, який розташовується в конкретній таблиці БД, об'єктне представлення елемента таблиці
        Об'єкт певного класу, у властивостях якого розташовуються дані полів таблиці

    Моделі знаходяться в app

    php artisan make:model Page - створити модель
    php artisan make:model Page -m - створити модель і міграцю

Урок 21. Модель даних Eloquent (softDelete, create, delete, update)

    Робота з методом create()

    По замовчуванню фреймворк забороняє вставляти дані в таблиці методом create() для досягнення найбільшої безпеки

    У моделі можна визначати, які поля можна заповняти, а які — не можна (fillable, guarded)

    softDelete реалізує щось схоже на корзину, робить помітку в полі deleted_at

Урок 22. Модель даних Eloquent. Зв'язки між таблицями

    Створюючи таблиці, ми їх можемо зв'язати, використовуючи зовнішній ключ

    Один до одного (користувач - місто, тобто один користувач може проживати лише в одному місті)

    Зовнішній ключ: $table->foreign('user_id')->references('id')->on('users');

    Зв'язок моделі користувача: return $this->hasOne('App\Country');

    Один до багатьох. (користувач - записи, один користувач і багато записів)

    Багато до багатьох. Користувачі і ролі. Користувач може мати багато ролей. А ролі можуть мати багато користувачів

Урок 23. Використання зв'язків між моделями Eloquent. Вставка і редагування

    Жадне завантаження дозволяє значно зменшити кількість запитів, виконуваних на сервері БД

    Ліниве завантаження - завантажити всі записи і потім звертатися до моделі користувача, щоб завантажувати записи по одному

    Жадне завантаження - дані з таблиць підвантажуються одночасно з колекцією моделей
    $articles = Article::with('user')->get();
    або
    $articles->load('user');

    Метод has() дозволяє вибрати інформацію для конкретної моделі якщо у неї є визначений зв'язок з моделлю

    Якщо працюємо з масивом даних, то для додавання більш коректно використовувати метод create()

    Якщо працюємо з моделями, то більш коректно використовувати метод save()

    Для редагування використовуємо метод update()

Урок 24. Мутатори

    Метод associate() використовується для змінення зв'язків між моделями

    associate() змінює значення визначеної властивості моделі

    attach() створює новий запис в таблиці для зв'язку багато до багатьох
    detach() видаляє створений запис в таблиці для зв'язку багато до багатьох

    Методи читачі - accessors
       Виконують певний код, коли відбувається звернення до властивості моделі

    Методи перетворювачі - мутатори
        Виконують певний код, коли відбувається змінення властивостей моделі

Урок 25. Валідація даних

    Валідація - перевірка вхідних даних на відповідність певним правилам

    ValidatesRequests - трейт, який потрібний для валідації данних

    validate() - метод, який реалізує процес валідації даних

    Правила:
        required - обов'язкове для заповнення
        max:10 - максимум 10 символів
        email - перевірка на правильність заповнення email

    Усі правила валідації: https://laravel.com/docs/5.2/validation#available-validation-rules

Урок 26. Валідація масивів

    Ручна побудова валідатора здійснюється за допомогою фасада Validator::

    Фасад надає доступ до чого-небудь

Урок 27. Повідомлення помилок валідації

    Всі правила валідації знаходяться в resources > lang > en > validation.php

    В масиві custom можна описати свої помилки валідації

    Параметри, які задаються в правилах і виводяться в помилках вказуються так - :max, :name

    Метод messages() буде також використовуватися для формування власних повідомлень в класі для валідації даних

    Масив messages[] - це масив користувацьких повідомлень про помилки валідації

    $this->validate($request, $rules, $messages);

    fails() повертає істину, якщо валідація була завершена з помилками

Урок 28. Автентифікація користувачів

    Автентифікація - це процес перевірки користувача з даними зареєстрованих користувачів сайту

    Авторизація - процес перевірки прав користувача на виконання дії

    config > auth.php

    defaults - стандартні налаштування
        guard - група налаштувань
        passwords - параметр, який визначає логіку скидання пароля (група налаштувань)

    guards - доступні охоронці нашого додатку
        web - група налаштувань
            driver - як буде передаватися інформація про те, що користувач автентифікований (session чи token)
            provider - вказує як будуть витягуватися дані про користувача

    providers - механізм, який дозволяє витягнути з деякого сховища інформацію про користувача

    users - група налаштувань
        driver - використання драйвера (реляційна модель eloquent)
        model - модель, яка буде використовуватися для роботи з користувачем

    passwords - налаштовує механізм скидання паролю
        users - група налаштувань
            provider - провайдер, який використовується для доступу до інформації користувача
            email - інформація про шаблон сторінки скидання пароля користувача
            table - назва таблиці, яка буде використовуватися для скидання пароля
            expire -

    Механізм аутентифікації користувачів складається з 2 частин:
        guards - охоронець
        providers - провайдер

    guards - визначає як користувачі проходять перевірку достовірності для кожного запиту

    providers - визначає, як можна отримати дані користувача з БД чи іншого місця зберігання інформації

    Можно створювати свої guard i provider

    php artisan make:auth

    resources > views > login.blade.php - вид для здійснення аутентифікації
    resources > views > register.blade.php - ви для реєстрації

    resources > views > emails > password.blade.php - шаблон листа, який буде надісланий на пошту для скидання пароля

    Шаблони, які необхідні для системи скидання паролю користувачів:
        resources > views > passwords > email.blade.php
        resources > views > passwords > reset.blade.php

    php artisan route:list - переглянути зареєстровані роути

Урок 29. Аутентифікація користувачів №2

    Гість - користувач, який не автентифікувався на сайті

    Вся система аутентифікації користувачів працює за рахунок конкретного guard

    При невірному введенні пароля виконується захист від брута: ір блокується на 1 хвилину

Урок 30. Методи фасаду Auth

    Auth => Illuminate\Support\Facades\Auth::class

    Фасад надає доступ до деякої властивості в яку раніше був записаний об'єкт певного класу

    Головний метод сервіс провайдера register()

    Auth::check() - перевірка аутентифікації користувача без посередника

    метод attempt() утентифікує конкретного користувача

Урок 31. Авторизація користувачів, Gate, налаштування прав користувача

    Авторизація визначає список доступних прав для кожного користувача

    Авторизація — це процес перевірки користувача на виконання будь-якої дії

    Клас Gate використовується для описання прав користувача

    define() - визначає певне правило для конкретного користувача

    Приклад встановлення правил:
    $gate->define('update-article', function(User $user, $article){
                foreach ($user->roles as $role){
                    if($role->name == 'Admin'){
                        if($user->id == $article->user_id){
                            return true;
                        }
                    }
                }

        return false;
    });

    Приклад перевірки правил:
    if(Gate::/*forUser(6)->*/allows('update-article', $article)){
        $article->name = $data['name'];
        $article->img = $data['img'];
        $article->text = $data['text'];

        $res = $user->articles()->save($article);

        return redirect()->back()->with('message', 'Матеріал оновлений');
    }

Урок 32. Класи політик авторизації

    Створення політик авторизації

    Політика авторизації — це клас, в якому описується набір правил, прив'язаних до однієї певної сутності

    Політика авторизації прив'язується до моделі проекта

    php artisan make:policy ArticlePolicy

    Після створення нової політики її потрібно зареєструвати в AuthServiceProvider ($policies)

    before() спрацьовує перед перевіркою будь-якого правила політики авторизації

    cannot() поверне істину, якщо користувачу заборонено використовувати конкретне правило

    can() поверне істину, якщо користувачу можна використовувати конкретне правило

Урок 33. Сесії

    Guard працює в парі з Session

    Після аутентифікації дані від запиту до запиту передаються саме за допомогою сесій

    Memcached - програмне забезпечення, яке реалізує сервіс кешування даних в оперативній пам'яті
        Дані сесії зберігаються як ключ-значення

    Redis - не реляційна високопродуктивна система керування БД
        Дані зберігаються в оперативній пам'яті у вигляді ключ-значення

    Щоб сесії зберігались у файлах:
        .env > SESSION_DRIVER=database
        session.php > 'driver' => env('SESSION_DRIVER', 'database'),

    $request->session()->all() отримати всі дані сесії
    put() покласти дані в сесію
    push() щоб додати комірку в масив, який в сесії
    forget() для видалення комірок
    flush() щоб очистити сесію повністю
    pull() повертає значення комірки по ключу і відразу видаляє її
    flash() зберігає дані в сесію але лише на 1 запит
    reflash() продовжити зберігання даних ще на 1 запит

Урок 34. Обробка подій

    Подія - це визначений момент роботи додатку або спеціальне повідомлення, яке виникає в певний момент часу
        Дане повідомлення формуємо ми, як і обробник певної події

    Як тільки відпрацює певна подія, зразу відпрацює його обробник

    Події представлені реалізацією патерна Observer

    php artisan event:generate - згенерувати класи, які описані в закритій властивості Listeners

    Треба створити клас події та її слухача

    Далі треба ініціювати викидання події: Event::fire(new onAddArticleEvent($res,$user));

    Налаштування логування:
        app > config > app.php > 'log' => env('APP_LOG', 'daily'),
        single - один файл
        daily - щоденно один файл новий

    Log::info('Article save in database', [$event->user_name => $event->article_name]);

Урок 35. Локалізація

    resources > lang > en

    Кожна локалізація має розташовуватися у відповідній папці з кодом мови en, ru

    Мовні константи - певні значення, які використовуються для відображення певної інформації на екран і які належать переводу

    Кожен словник повинен повертати асоціативний масив ключів і тексту-пояснення

    Lang::get('messages.welcome'); поверне переведений текст для певної мовної константи

    'hello' => 'Привіт :name' - підтримка динамічних властивостей

    Множинне число для переводу:
        'apple' => 'яблуко|яблука|яблук'
        $title_head = Lang::choice('messages.apple', 5);
            1 - якщо одне           (яблуко)
            2 - якщо 2 або більше   (яблука)
            22 - якщо дуже багато   (яблук)

Урок 36. Контракти, реалізація інтерфейсів

    Контракти - це набір класів і інтерфейсів, які визначають певний функціонал фреймворка

    Якщо є інтерфейс, то має бути і клас, який реалізує його функціонал

    У одного контракту може бути декілька класів реалізаторів

    Інтерфейси потрібні для слабкої зв'язки і спрощення коду

    Логіка відокремлюється від дій

    За допомогою сервіс провайдерів можна прописати залежність між інтерфейсом і класом реалізатором

    Контракт - інтерфейс, який визначає єдине АРІ для класів реалізаторів даного контракту

Урок 37. Сервіс провайдери

    Сервіс провайдери (поставники послуг) — призанчені для першочергового завантаження додатку, елементів і сервісів

    Передбачає реєстрацію необхідних класів у сервіс-контейнері

    config > app.php > providers - список доступних сервіс-провайдерів, які завантажуються при старті додатку

    У сервіс контейнері реєструються всі необхідні сервіси

    bind() для прив'язки певної функції до певної комірки сервіс-провайдера
    Прив'язує реалізатор з інтерфейсом


